
/*
 Twitter RFID Web Client
 Language: Arduino
 */
#include <Wire.h>

#define BUFFER_SIZE 24
// commands for RFID reader:
const int RESET = 0x80;      
const int SELECT = 0x83;
const int AUTHENTICATE = 0x85;
const int READ = 0x86;




//int data[];                // array of new data

const boolean DEBUG = false;
int availableBytes = 0;

int command = 0;               // received command, from the packet    
int packetLength = 0;          // length of the response, from the packet
int checksum = 0;              // checksum value received
unsigned long tagNumber = 0;    	       // tag number 
int tagType = 0;               // the type of tag
int errorCode = 0;             // error code from some commands
String errorMsg = "";          // descriptive error message
int antennaPower = 1;          // antenna power level
int versionNumber = 003;       // version of the library


unsigned long lastTag = 0;          // address of the previous tag
int addressBlock = 4;               // memory block on the tag to read
boolean authenticated = false;      // whether you successfully authenticated the tag
byte responseBuffer[BUFFER_SIZE];            // To hold the last response from the reader

void setup() {
  Serial.begin(9600);
  Wire.begin();
  delay(2000);
  reset();
 selectTag();
 delay(1000);
 seekTag();  
 delay(1000);
 getCommand();
 Serial.print("Command: ");
 Serial.println(command, HEX);
 getPacketLength();
 Serial.print("packet length: ");
 Serial.println(packetLength);
 getCheckSum();
  Serial.print("checksum: ");
 Serial.println(checksum, HEX);
 getTagNumber();
  Serial.print("tag number: ");
  Serial.println(tagNumber, HEX);
 getTagType();
  Serial.print("tag Type: ");
  Serial.println(tagType, HEX);
 getErrorCode();
  Serial.print("error code: ");
  Serial.println(errorCode, HEX);
 getErrorMessage();
  Serial.println(errorMsg);
 getAntennaPower();
delay(1000);
 getFirmwareVersion();
 Serial.println(errorMsg);
// authenticate(int thisBlock);
// authenticate(int thisBlock, int authentication);
// authenticate(int thisBlock, int authentication, int *thisKey);
// readBlock(int block);
// writeBlock(int thisBlock, String thisMessage) ;
// writeFourByteBlock(int thisBlock, String thisMessage);
 setAntennaPower(1);
 delay(1000);
// sleep();
 setBaudRate(19200);
delay(10000);
}

void loop() {
  seekTag();  
 delay(1000); 
  getTagNumber();
  Serial.print("tag number: ");
  Serial.println(tagNumber, HEX);
 getTagType();
  Serial.print("tag Type: ");
  Serial.println(tagType, HEX);
}


// Retrieve a response from the reader
// from any command:

int getData() {  
  command = 0;
  int count = 0;
  // The reader can't respond in less than
  // 50 ms:
  delay(50);
  // get response from reader:
  Wire.requestFrom(0x42, BUFFER_SIZE);
  while (!Wire.available()) Serial.print(".");
  // while data is coming from the reader,
  // add it to the response buffer:
  while(Wire.available())  {     
    responseBuffer[count] = Wire.read();  
    count++;
  }  
  // put a 0 in the last byte after the reponse:
  responseBuffer[count] = 0;

  // fill in the global variables:
  packetLength = responseBuffer[0];
  command = responseBuffer[1];
  checksum = responseBuffer[count-1];

  printBuffer(count);

  // if packet length is 2, you have only a command and an error code:
  if (packetLength < 3) {
    errorCode = responseBuffer[2];
    tagType = 0;
    tagNumber = 0;
  } 
  else {
    errorCode = 0; 
    errorMsg = "";
  }


  // some messages generate error codes.  Return them here.
  switch (command) {
    // reset produces nothing as of version 2.8 of the SM130 firmware:
  case 0x80:
    break;
    // firmware version only produces the firmware version:
  case 0x81: 
    errorCode = 0;
    tagType = 0;
    tagNumber = 0;
    // errorMsg = "Firmware version: ";
    // if you got a good payload, it's the version number
    // add the response to the string:
    if (packetLength > 2) {
      int i = 2;
      while (isPrintable(responseBuffer[i])) {
        errorMsg += (char)responseBuffer[i];
        i++;
      }
    }
    break;
  case 0x82:  // seekTag    
    if (errorCode == 0x55) {
      errorMsg = "Reader error: Antenna is off";
    }
    if (errorCode == 0x4C) {
      errorMsg = "Command in Progress";
    }
    // if you got a good payload, it's a tag number:
    if (packetLength > 2) {
      // get the tag type:
      tagType = responseBuffer[2];
      // tag bytes come in reverse order:
      for (int thisByte = packetLength; thisByte >= 3; thisByte--) {
        // shift the current byte up one byte:
        tagNumber = tagNumber << 8;
        // add the new byte to the end of the tag:
        tagNumber += responseBuffer[thisByte]; 
      }
    }
    break;
  case 0x83:  // selectTag
    switch(errorCode) {
    case 0x4E:
      errorMsg = " Reader error: No Tag present";
      break;
    case 0x55:
      errorMsg = " Reader error: Access failed because RF field is off";
      break;
    }
    // if you got a good payload, it's a tag number:
    if (packetLength > 2) {
      // get the tag type:
      tagType = responseBuffer[2];
      // tag bytes come in reverse order:
      for (int thisByte = packetLength; thisByte >= 3; thisByte--) {
        // shift the current byte up one byte:
        tagNumber = tagNumber << 8;
        // add the new byte to the end of the tag:
        tagNumber += responseBuffer[thisByte]; 
      }
    }
    break;
  case 0x85:  //authenticate
    switch(errorCode) {
    case 0x45:
      errorMsg = " Reader error: Invalid key format in EEPROM";
      break;
    case 0x4C:
      errorMsg = "Login successful";
      break;
    case 0x4E:
      errorMsg = " Reader error: No tag present, or login failed";
      break;
    case 0x55:
      errorMsg = " Reader error: login failed";
      break;
    }
    break;
  case 0x86:  //read block
    switch(errorCode) {
    case 00:
      // good read
      break;
    case 0x4E:
      errorMsg = "Reader error: no tag present";
      break;
    case 0x46:
      errorMsg = "Reader error: read failed";
      break;
    }
    break; 
  case 0x87:  //read value block
    switch(errorCode) {
    case 0x4E:
      errorMsg = "Reader error: no tag present";
      break;
    case 0x46:
      errorMsg = "Reader error: read failed";
      break;
    case 0x49:
      errorMsg = "Reader error: you tried to read a block number that isn't a value block";
      break;
    }
    break; 
  case 0x89:  //write  block
    switch(errorCode) {
    case 0x55:
      errorMsg = "Reader error: data read doesn't match data write";
      break;
    case 0x58:
      errorMsg = "Reader error: the block you tried to write to is protected";
      break;
    case 0x4E:
      errorMsg = "Reader error: no tag present";
      break;
    case 0x46:
      errorMsg = "Reader error: write failed";
      break;
    }
    break; 
  case 0x8A:  //write value block
    switch(errorCode) {
    case 0x4E:
      errorMsg = "Reader error: no tag present";
      break;
    case 0x46:
      errorMsg = "Reader error: read failed during verification";
      break;
    case 0x49:
      errorMsg = "Reader error: you tried to write to a block number that isn't a value block";
      break;
    }
    break; 
  case 0x8B:  //write  4 byte block
    switch(errorCode) {
    case 0x55:
      errorMsg = "Reader error: data read doesn't match data write";
      break;
    case 0x58:
      errorMsg = "Reader error: the block you tried to write to is protected";
      break;
    case 0x4E:
      errorMsg = "Reader error: no tag present";
      break;
    case 0x46:
      errorMsg = "Reader error: write failed";
      break;
    }
    break; 
  case 0x8C:  //write master key
    switch(errorCode) {
    case 0x4E:
      errorMsg = "Reader error: write master key failed";
      break;
    case 0x4C:
      // success!
      break;
    }
    break; 
  case 0x90:     // set antenna status
    errorCode = 0;
    antennaPower = responseBuffer[2];
    break;
  case 0x94:  //set baud rate
    switch(errorCode) {
    case 0x4E:
      errorMsg = "Reader error: set baud rate failed";
      break;
    case 0x4C:
      // success!
      errorMsg = "Baud rate set";
      break;
    }
    break; 
  } 
  // return the length of the response:
  return count;
}


// This method sends a command to the 
// RFID readers via I2C. This function is 
// overloaded, meaning there are two versions, so you
// can call it in more than one way:

void sendCommand(int thisCommand) {
  byte length = 1;
  // convert the byte to an array:
  int commandBuffer[] = {
    thisCommand                  };
  // call the other sendCommand method:
  sendCommand(commandBuffer, length);
}

// Send a command to the reader
//

void sendCommand(int command[], int length) {
  Wire.beginTransmission(0x42); 
  int checksum = length;       // Starting value for the checksum.
  Wire.write(length);          // send the length

    for (int i = 0; i < length; i++) {
    checksum += command[i];    // Add each byte to the checksum
    Wire.write(command[i]);    // send the byte
  }

  // checksum is the low byte of the sum of 
  // the other bytes:
  checksum = checksum % 256; 
  Wire.write(checksum);        // send the checksum
  Wire.endTransmission();      // end the I2C connection

    // you just sent a new command, so there's no new data available:

  clearBuffer();
}


int available() {
  return availableBytes;
}


int getCommand() {
  return command;
}
/**
 * @return  packetLength the length of the payload as reported by the reader
 * 
 */
int getPacketLength() {
  return packetLength;
}
/**
 * @return  checksum the checksum from the reader
 * 
 */
int getCheckSum() {
  return checksum;
}
/**
 * @return  payload the array of bytes in the payload of the message
 * 
 */
//int[] getPayload() {
//  return payload;
//}

/**
 * @return  tagNumber the array of bytes in the tag number of the message
 * 
 */
long getTagNumber() {
  return tagNumber;
}


/**
 * Assuming there's a valid tag read, this returns the tag type, as follows:
 *
 * 0x01 Mifare Ultralight 
 * 0x02 Mifare Standard 1K 
 * 0x03 Mifare Classic 4K 
 * 0xFF Unknown Tag type 
 *
 * @return  tagType an integer for the tag type
 * 
 * 
 */
int getTagType() {
  return tagType;
}



int getErrorCode() {
  return errorCode;
}

/**
 * 
 * @return  errorMsg    the descriptive error message
 */
String getErrorMessage() {
  return errorMsg;
}
/**
 * 
 * @return  antennaPower    the antenna power.  0x00 is off, anything else is on
 */
int getAntennaPower() {
  return antennaPower;
}
/**
 * Sends the Seek Tag command (0x83)
 *
 */
/**
 * Resets the reader by sending command 0x80
 *
 */
void reset() {
  sendCommand(0x80);
  // reset gets no response as of I2C version 2.8
}

/**
 * gets the firmware of the reader by sending command 0x81
 *
 */
void getFirmwareVersion() {
  sendCommand(0x81);
  // wait for a response:
  getData();
}


/**
 * Sends the Select Tag command (0x82)
 *
 */
void selectTag() {
  sendCommand(0x83);
  getData();
}


void seekTag() {
  sendCommand(0x82);
  getData();
}


// Authenticate yourself to the RFID tag.
//
boolean authenticate(int thisBlock) {
  int length = 3;
  int command[] = {
    AUTHENTICATE,  // authenticate
    thisBlock,
    0xFF  		  // default encryption
  };  
  authenticate(thisBlock, 0xFF, 0);
}


boolean authenticate(int thisBlock, int authentication) {
  authenticate(thisBlock, authentication, 0);
}

boolean authenticate(int thisBlock, int authentication, int *thisKey) {
  int length = (sizeof(thisKey)/sizeof(int)) + 3;
  int command[length];
  command[0] = AUTHENTICATE,  // authenticate
  command[1] = thisBlock;
  command[2] = authentication;
  for (int i=0; i<length-3; i++) {
    command[i+3] = thisKey[i];
  }

  // send the command:
  sendCommand(command, length);

  // wait for a response:
  getData();

  // response 0x4C (ASCII L) means
  // you successfully authenticated
  if (responseBuffer[2] == 0x4C) {
    return true;
  } 
  else {
    // No tag or login failed
    return false;
  }
}


/*
// Read a block. You need to authenticate() 
 // before you can call this.
 
 //TODO: Make sure this is generic
 
 int readBlock(int block) {
 int length = 2;
 int command[] = {
 READ,  // read block
 block 
 };
 // send the command:
 sendCommand(command, length);  
 // get 20 bytes (3 response + 16 bytes data + checksum)
 int count = getData(20);  
 // response 0x4E (ASCII N) means no tag:
 if (responseBuffer[2] == 0x4E) { 
 return 0;
 } 
 // response 0x46 (ASCII F) means read failed:
 else if (responseBuffer[2] == 0x46) {
 return 0;
 }
 return count;
 }
 
 */


void writeBlock(int thisBlock, String thisMessage) {
  //  // block needs to be broken into 16-byte sections
  //  if (thisMessage.length() > 16) {
  //    errorMsg = "You can't send more than 16 bytes with a writeBlock() command.";
  //  } 
  //  else {
  //    int thisCommand[] = {
  //      0x89,thisBlock                                                                                   }; 
  //    int thisByte;
  //    // make sure to write to all 16 bytes:
  //    for (int i = 0; i < 16; i++) {
  //      if (i < thisMessage.length()) {
  //        thisByte = (int)thisMessage.charAt(i);
  //      } 
  //      else {
  //        thisByte = 0;
  //      }
  //      thisCommand = parent.append(thisCommand, thisByte);
  //    } 
  //
  //    sendCommand(thisCommand);
  //  }
}
/**
 * Writes a 4-byte string to a block. If the string is less than 16 bytes
 * it fills the empty bytes with 0x00.  If more than 4 bytes, it generates
 * an error message.
 * Used for Mifare ultralight tags
 * 
 * You need to select and authenticate before ou can read or write.
 * 
 * @param thisBlock     Block to write to
 * @param thisMessage   4-byte string to write
 */
void writeFourByteBlock(int thisBlock, String thisMessage) {
  //  // block needs to be broken into 4-byte sections
  //  if (thisMessage.length() > 4) {
  //    errorMsg = "You can't send more than 4 bytes with a writeFourByteBlock() command.";
  //  } 
  //  else {
  //    int thisCommand[] = {
  //      0x8B,thisBlock                                                                                   }; 
  //    int thisByte;
  //    // make sure to write to all 4 bytes:
  //    for (int i = 0; i < 4; i++) {
  //      if (i < thisMessage.length()) {
  //        thisByte = (int)thisMessage.charAt(i);
  //      } 
  //      else {
  //        thisByte = 0;
  //      }
  //      thisCommand = parent.append(thisCommand, thisByte);
  //    } 
  //    sendCommand(thisCommand);
  //  }
}

/**
 * Sets the antenna power.  0x00 is off, anything else is on
 * @param level the antenna power level
 */
void setAntennaPower(int level) {
  int thisCommand[] = {
    0x90, level              };
  sendCommand(thisCommand, 2);
  getData();
}

/**
 * Sends the sleep command (0x96)
 *
 */
void sleep() {
  sendCommand(0x96);
  getData();
}

void setBaudRate(int baudRate) {

  int dataRate = 00;

  switch (baudRate){
  case 9600:
    dataRate = 0x00;
    break;
  case 19200:
    dataRate = 0x01;
    break;
  case 38400:
    dataRate = 0x02;
    break;
  case 57600:
    dataRate = 0x03;
    break;
  case 115200:
    dataRate = 0x04;
    break;
  }
  int thisCommand[] = { 
    0x94, dataRate              }; 
  sendCommand(thisCommand, 2);
  // wait for a response:
  getData();
}

void clearBuffer() {
  for (int i = 0; i < BUFFER_SIZE; i++) {
    responseBuffer[i] = 0;
  } 
}

void printBuffer(int count) {
  for (int i = 0; i < count; i++) {
    Serial.print(responseBuffer[i], HEX);
    Serial.print(" ");
  } 
  Serial.println();
}









